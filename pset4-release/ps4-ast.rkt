#lang plai-typed

; WARNING: DO NOT EDIT THIS FILE

; In this assignment, our programs can return different kinds of
; results. For some of these kinds of results, it is up to you to
; determine how you want to represent them (e.g. objects) Since these
; values are implementation dependent, it does not make sense to compare
; for testin/grading purposes. For example, your implementation of boxes
; may assign locations in a different, non-deterministic way compared to
; the reference solution, so it doesn't make sense to have a test case
; expecting that you return a box allocated at a particular location.
; 
; However, for certain other kinds of values (sometimes called "ground"
; or "base" values) like numbers or booleans, it does make sense to
; compare the values your interpreter returns with the one the reference
; solution returns. These values are captured in the following type:
; 

(define-type BaseValue
  [numBV (n : number)]
  [boolBV (b : boolean)])

; Expressions in the language.

; As a general rule of thumb, unless otherwise specified, evaluation
; order should be left to right.  i.e. for a constructor of the form
; (constrC e1 e2 e3 ... en), we will evaluate e1 first, then e2,
; etc., and finally evaluate en before carrying out the effects of the
; operation given by constrC.

(define-type Expr
  [numC (n : number)]
  [boolC (b : boolean)]

  ; (+ e1 e2)
  ; Evaluates e1 and then e2, which can both be assumed to yield numbers n1 and n2, and returns their sum.
  [plusC (e1 : Expr) (e2 : Expr)]

  ; (* e1 e2)
  ; Evaluates e1 and then e2, which can both be assumed to yield numbers n1 and n2, and returns their product.
  [timesC (e1 : Expr) (e2 : Expr)]

  ; (equal? e1 e2)
  ; Evaluates e1 and then e2, and returns true if e1 is equal to e2, and returns false otherwise.
  ; You can assume that the only values being compared are things that could be represented as BaseValues
  ; i.e. we will not compare two objects.
  [equal?C (e1 : Expr) (e2 : Expr)]

  ; (if guard e1 e2)
  ; Evaluates guard, which can be assumed to yield a boolean b.
  ; - If b is true, evaluates e1 and returns the result.
  ; - If b is false, evaluates e2 and returns the result.
  [ifC (guard : Expr) (e1 : Expr) (e2 : Expr)]


  ;;;;; The next 4 constructors are parsed and behave as in lecture 6 ;;;;;;

  ; (let x e1 e2)
  ; would be parsed as (letC x e1 e2)
  [letC (x : symbol) (e1 : Expr) (e2 : Expr)]

  ; (lambda x e)
  [lambdaC (x : symbol) (e : Expr)]

  ; (e1 e2)
  [appC (e1 : Expr) (e2 : Expr)]

  ; Occurrence of a variable/identifier
  [idC (x : symbol)]

  [beginC (es : (listof Expr))]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; Objects can be created using two possible forms, the first is:
  ;
  ; (object ([field1 def1] [field2 def2] .... [fieldN defN])
  ;         ([method-name1 (self arg1 arg2 ...) body1] ...
  ;          [method-nameN (self arg1 arg2 ...) bodyN]))

  ; which should parse to (objectC (none) (list (pair field1 def1) ... (pair fieldN defN))
  ;                          (list (method-decl method-name1 (list self arg1 arg2 ...) body1) ...
  ;                                (method-decl method-nameN (list self arg1 arg2 ...) bodyN)))

  ; This creates an object with fields of name field1, ..., fieldN with initial values def1 through defN.
  ; (evaluted from left to right). and methods given by the method declarations.
  ; Each method takes a list of arguments, which always starts with an initial argument that will
  ; be bound to the object itself when executed
  ; (this is customarily named 'self') but need not be. 

  ; The second way to create an object is with the object delegation form:

  ; (object-del e
  ;         ([field1 def1] [field2 def2] .... [fieldN defN])
  ;         ([method-name1 (self arg1 arg2 ...) body1] ...
  ;          [method-nameN (self arg1 arg2 ...) bodyN]))

  ; which should parse to (objectC (some e) (list (pair field1 def1) ... (pair fieldN defN))
  ;                          (list (method-decl method-name1 (list self arg1 arg2 ...) body1) ...
  ;                                (method-decl method-nameN (list self arg1 arg2 ...) bodyN)))

  ; Note the difference is that the first argument to the constructor is (some e) instead of none.
  ; When executed, this should first evaluate e, which should yield some object o', then evaluates
  ; the field definitions and then creates an object o. The object o should behave similarly to the previous
  ; form, except that when it receives a method invocation for method m, if the method m is NOT one of the methods
  ; in method-name1 through method-nameN, then o invokes method m on o', passing the same arguments.
  ; (In particular, when o invokes m on o', it passes o as the 'self' argument , NOT o').

  ; See the discussion in https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html
  ; for further explanation of delegation.

  [objectC (delegate : (optionof Expr))
           (fields : (listof (symbol * Expr)))
           (methods : (listof MethodDecl))
           ]

  ; (msg o m arg1 ... argN)
  ; Invokes the method m on object o passing the list of arguments (list arg1 ... argN).

  [msgC (o : Expr) (method : symbol) (args : (listof Expr))]

  ; Returns the value of the field given by name
  ; (get-field name)
  [get-fieldC (name : symbol)]

  ; (set-field! name e)
  ; Evaluates e yielding some value v and then updates the field name to have value v.
  [set-field!C (name : symbol) (e : Expr)]
  
  )

(define-type MethodDecl
  [method-decl (name : symbol) (args : (listof symbol)) (body : Expr)])
