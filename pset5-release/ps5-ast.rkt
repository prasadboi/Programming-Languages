#lang plai-typed

; WARNING: DO NOT EDIT THIS FILE

; For short hand, we will write "e : t" to mean that e should have type t.

(define-type Expr

  ; (numC n) : numT
  [numC (n : number)]

  ; (voidC) : voidT
  [voidC]

  ; (boolC b) : boolT 
  [boolC (b : boolean)]

  ; if e1 : t1 and e2 : t2, then (pairC e1 e2) : (pairT t1 t2)
  [pairC (e1 : Expr) (e2 : Expr)]

  ; if e : (pairT t1 t2) for some t1 and t2, then (fstC e) : t1
  [fstC (e : Expr)]

  ; if e : (pairT t1 t2) for some t1 and t2, then (sndC e) : t2
  [sndC (e : Expr)]

  ; e1 : numT, e2 : numT, then (plusC e1 e2) : numT
  [plusC (e1 : Expr) (e2 : Expr)]

  ; e1 : numT, e2 : numT, then (timesC e1 e2) : numT
  [timesC (e1 : Expr) (e2 : Expr)]

  ; e1 and e2 should both have the same type t, for some type t. Then, (equalC e1 e2) will have type boolT.
  [equal?C (e1 : Expr) (e2 : Expr)]

  ; if e1 has type t for some t, then e2 should have some type t' for some t'
  ; under an environment in which x maps to t.
  ; Then, overall, (letC x e1 e2) will have type t'.
  ; NOTE: in class we required letC to have a type annotation saying what the type t should be,
  ; but in this assignment we will not assume that.
  [letC (x : symbol) (e1 : Expr) (e2 : Expr)]

  ; under an environment in which x has type argT, e should have some type retT,
  ; then (lambdaC x argT retT) : (funT argT retT)
  [lambdaC (x : symbol) (argT : Type) (e : Expr)]

  ; e1 : (funT t1 t2), e2 : t1, then (appC e1 e2) : t2
  [appC (e1 : Expr) (e2 : Expr)]

  ; if x is in an environment that maps x to type t, then (idC x) : t
  [idC (x : symbol)]

  ; e : boolT, e1 : t, and e2 : t, then (ifC e e1 e2) : t
  [ifC (e : Expr) (e1 : Expr) (e2 : Expr)]

  ; (emptyC t) : (listT t)
  [emptyC (t : Type)]

  ; e1 : t, e2 : (listT t), then (consC e1 e2) : listT t
  [consC (e1 : Expr) (e2 : Expr)]

  ; e : (listT t), then (firstC e) : t
  [firstC (e : Expr)]

  ; e : (listT t), then (restC e) : (listT t)
  [restC (e : Expr)]

  ; e : (listT t) for some type t, (is-empty?C e) : boolT
  [is-empty?C (e : Expr)]

  ; under an environment in which x has type argT and f has type (funT argT retT),
  ; e should have type retT; then (recC f x argT retT) : (funT argT retT)
  [recC (f : symbol) (x : symbol) (argT : Type) (retT : Type) (e : Expr)]

  ; e : t, for some type t, then (boxC e) : (boxT t)
  [boxC (e : Expr)]

  ; (e : boxT t) for some type t, then (unboxC e) : t
  [unboxC (e : Expr)]

  ; (e1 : boxT t) and (e2 : t), then (set-box!C e1 e2) : voidT
  [set-box!C (e1 : Expr) (e2 : Expr)]
  )

(define-type Type
  [numT]
  [boolT]
  [voidT]
  [pairT (t1 : Type) (t2 : Type)]
  [listT (t : Type)]
  [boxT (t : Type)]
  [funT (arg : Type) (ret : Type)])

