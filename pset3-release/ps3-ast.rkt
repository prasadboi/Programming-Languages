#lang plai-typed

; WARNING: DO NOT EDIT THIS FILE

; In this assignment, our programs can return different kinds of
; results. For some of these kinds of results, it is up to you to
; determine how you want to represent them (e.g. boxes, closures, and
; vector values).  Since these values are implementation dependent, it
; does not make sense to compare for testin/grading purposes. For
; example, your implementation of boxes may assign locations in a
; different, non-deterministic way compared to the reference solution,
; so it doesn't make sense to have a test case expecting that you return
; a box allocated at a particular location.
; 
; However, for certain other kinds of values (sometimes called "ground"
; or "base" values) like numbers or booleans, it does make sense to
; compare the values your interpreter returns with the one the reference
; solution returns. These values are captured in the following type:

(define-type BaseValue
  [numBV (n : number)]
  [boolBV (b : boolean)]
  [pairBV (v1 : BaseValue) (v2 : BaseValue)])

; Expressions in the language.

; As a general rule of thumb, unless otherwise specified, evaluation
; order should be left to right.  i.e. for a constructor of the form
; (constrC e1 e2 e3 ... en), we will evaluate e1 first, then e2,
; etc., and finally evaluate en before carrying out the effects of the
; operation given by constrC.

(define-type Expr
  [numC (n : number)]
  [boolC (b : boolean)]

  ; (pair e1 e2)
  ; evaluates e1 and then e2, returns a pair containing the resulting values
  [pairC (e1 : Expr) (e2 : Expr)]

  ; (fst e)
  ; evaluates e, which can be assumed to yield a pair, and then returns the first component of the pair.
  [fstC (e : Expr)]

  ; (snd e)
  ; evaluates e, which can be assumed to yield a pair, and then returns the snd component of the pair.
  [sndC (e : Expr)]

  ; (+ e1 e2)
  ; Evaluates e1 and then e2, which can both be assumed to yield numbers n1 and n2, and returns their sum.
  [plusC (e1 : Expr) (e2 : Expr)]

  ; (* e1 e2)
  ; Evaluates e1 and then e2, which can both be assumed to yield numbers n1 and n2, and returns their product.
  [timesC (e1 : Expr) (e2 : Expr)]

  ; (equal? e1 e2)
  ; Evaluates e1 and then e2, and returns true if e1 is equal to e2, and returns false otherwise.
  ; You can assume that the only values being compared are things that could be represented as BaseValues
  ; i.e. we will not compare two vectors or two boxes.
  [equal?C (e1 : Expr) (e2 : Expr)]

  ; (if guard e1 e2)
  ; Evaluates guard, which can be assumed to yield a boolean b.
  ; - If b is true, evaluates e1 and returns the result.
  ; - If b is false, evaluates e2 and returns the result.
  [ifC (guard : Expr) (e1 : Expr) (e2 : Expr)]


  ;;;;; The next 7 constructors are parsed and behave as in lecture 6 ;;;;;;

  ; (let x e1 e2)
  ; would be parsed as (letC x e1 e2)
  [letC (x : symbol) (e1 : Expr) (e2 : Expr)]

  ; (lambda x e)
  [lambdaC (x : symbol) (e : Expr)]

  ; (e1 e2)
  [appC (e1 : Expr) (e2 : Expr)]

  ; Occurrence of a variable/identifier
  [idC (x : symbol)]

  ; (box e)
  [boxC (e : Expr)]

  ; (unbox e)
  [unboxC (e : Expr)]

  ; (set-box! e1 e2)
  [setboxC (e1 : Expr) (e2 : Expr)]

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; Vector operations. As a general rule of thumb, these behave similarly to Racket's vector operations.

  ; (vector e1 e2 ... en)
  ; evaluates e1, then e2, then ..., en, yielding values v1 through vn
  ; creates a mutable vector of length n containing these values and returns it.
  [vectorC (es : (listof Expr))]

  ; (vector-length e)
  ; evaluates e, which can be assumed to yield a vector v, and then returns the length of v.
  [vector-lengthC (e : Expr)]

  ; (vector-ref e1 e2)
  ; evaluates e1, which can be assumed to yield a vector v, then
  ; evaluates e2, which can be assumed to yield an integer number n
  ; such that 0 <= n <= length of v, and then returns the value at
  ; position n in the vector v

  [vector-refC (e1 : Expr) (e2 : Expr)]

  ; (vector-set! e1 e2 e3)
  ; evaluates e1, which can be assumed to yield a vector v, then
  ; evaluates e2, which can be assumed to yield an integer number n
  ; such that 0 <= n <= length of v, and then evaluates e3, yielding some value v'
  ; then it updates position n at vector v to be the value v'
  [vector-set!C (e1 : Expr) (e2 : Expr) (e3 : Expr)]

  ; (vector-make e1 e2)
  ; evaluates e1 which should yield an integer number n such that 0 <= n,
  ; then evalutes e2 to a value v.
  ; allocated a mutable vector of length n where each entry in the vector is of value v
  ; (Note: in actual Racket this is called make-vector instead)
  [vector-makeC (e1 : Expr) (e2 : Expr)]
  
  ; (subvector e1 offset len)
  ; evaluates e1, which should yield a vector v
  ; then evaluates offset, which should yield an integer number n such that 0 <= n <= length v
  ; then evaluates len, which should yield an integer number l such that 0 <= l and (n + l) <= length v
  ; returns a vector value v' of length l that refers to the same vector location as the original vector v,
  ; but where the v' vector's position i refers to the same location as
  ; positon (i + offset) in the original vector v
  ;
  ; e.g. if v is a vector and we were to do
  ; (let v (vector 1 2 3 4)
  ;   (begin (vector-set! (subvector v 1 3) 0 10)
  ;          (vector-ref v 1)))
  ; the result would yield 10, because the modification of the subvector
  ; affects the original vector v at position 1
  ;
  [subvectorC (e : Expr) (offset : Expr) (len : Expr)]

  ; (begin e1 e2 e3 ... en)
  ; evaluates e1, then e2, then e3, ... finally en, and returns the value resulting from evaluating en.
  [beginC (es : (listof Expr))]

  ; (transact e)
  ; evaluates e, which should yield a pair p, where the first component of the pair p is a boolean b
  ; if b is true, it returns the second component of p
  ; if b is false, it returns the second component of p,
  ; but all of the memory modifications performed during executing e are undone when (transact e) finishes.
  [transactC (e : Expr)]
  )

